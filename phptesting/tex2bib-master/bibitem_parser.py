import re
import string
import subprocess


class Bibentry(object):
    def __init__(self, publisher: str, address: str, year: str, title: str, author: str, ENTRYTYPE: str, ID: str):
        self.publisher = publisher
        self.address = address
        self.year = year
        self.title = title
        self.author = author
        self.ENTRYTPE = ENTRYTYPE
        self.ID = ID


class BibitemParser():
    """class for parsing bibitems in a file to author name tuples"""

    def __init__(self, php_convertion_script_file):
        self.php_convertion_script_file = php_convertion_script_file

    def strip_special_chars(self, unclean_string: str):
        """
        strips \newblock etc.
        ----------
        unclean_string : str
            the string that is to be cleaned
        """
        # print("NEBLOCKSTRIP: ", unclean_string)
        unclean_string = re.split(r"\\\S+", unclean_string)[1]
        # print("NEBLOCKSTRIP: ",unclean_string)
        unclean_string = unclean_string.strip()
        return unclean_string

    def strip_letter_encasing(self, unclean_string: str):
        """
        strips letter encasing of the form {a}
        ----------
        unclean_string : str
            the string that is to be cleaned
        """
        occurences = re.findall(r"{\S}|{}", unclean_string)
        for c in occurences:
            if (len(c) == 3):
                unclean_string = unclean_string.replace(c, c[1])
            if (len(c) == 2):
                unclean_string = unclean_string.replace(c, '')
        return unclean_string

    def clean_string(self, unclean_string: str):
        """
        cleans the raw string that is output by the php script
        ----------
        unclean_string : str
            the string that is to be cleaned
        """
        # remove leading spaces
        unclean_string = unclean_string.strip()

        # remove everything after linebreak
        unclean_string = unclean_string.split("\n")[0]

        if ("\\" in unclean_string):
            unclean_string = self.strip_special_chars(unclean_string)
            if len(unclean_string) <= 2 or unclean_string == None:
                return None

        # remove letterencasing
        unclean_string = self.strip_letter_encasing(unclean_string)
        if unclean_string == "":
            return None

        # remove encasing brackets
        if (unclean_string[0] == "{"):
            unclean_string = unclean_string[1:-1]

        if (unclean_string[-1] == "}"):
            if (len(unclean_string) <= 2):
                return
            unclean_string = unclean_string[0:-1]
            unclean_string = unclean_string.strip()

        if ("}" in unclean_string):
            unclean_string = unclean_string.split("}")[0]

        if (unclean_string[-1] == ","):
            if (len(unclean_string) <= 2):
                return
            unclean_string = unclean_string[0:-1]

        return unclean_string

    def convert_bibtexstring_2_author_title_tuple(self, bibtexstring):
        """
        Does cleanup work after the execution of the tex2bib script
        Parameters
        ----------
        bibtexstring : str
            the string that is generated by tex2bib
        """
        if len(bibtexstring) <= 7:
            return None, None
        title = bibtexstring.split("title =")[1].split("year =")[0][0:-2]
        author = bibtexstring.split("author =")[1].split("title =")[0][0:-2]

        title = self.clean_string(title)
        author = self.clean_string(author)

        unidentified = bibtexstring.split("unidentified = {")
        if len(unidentified) > 1:
            if title == None and unidentified != None and unidentified != "":
                title = self.clean_string(unidentified[1])

        return author, title

    def convert_texfile_2_author_title_tuples(self, tex_input_file):
        """
        Uses this Bib 2 convert tex2bib: https://github.com/juusechec/tex2bib
        that is based on :https://text2bib.economics.utoronto.ca/index.php/index
        Parameters
        ----------
        php_convertion_script_file : str
            the path to the convertion script file
        tex_input_file : str
            tex file with the bibitems that are to be converted
        """
        result = subprocess.run(
            ['php', self.php_convertion_script_file,
             tex_input_file],  # program and arguments
            text=True,
            capture_output=True,
            check=True  # raise exception if program fails
        )
        resultstring: string = result.stdout
        citationentriestrings = resultstring.split("\n\n")
        return list(map(self.convert_bibtexstring_2_author_title_tuple, citationentriestrings))[0:-1]

    def check_how_many_titles_are_usable(self, author_title_tuple_list: list):
        """
        analyses  author_title_tuple_list and checks if the titles are actually usable
        TODO add more functionality not just check for None and empty string
        ----------
        author_title_tuple_list: list
            author_tuple_titles list that is to be analysed
        """
        all_count = len(author_title_tuple_list)
        accepted = 0
        for author_title_tuple in author_title_tuple_list:
            if (author_title_tuple[1] != "" and author_title_tuple[1] != None):
                accepted += 1
        acceptancerate = accepted / all_count
        return accepted, all_count, acceptancerate


if __name__ == "__main__":
    tex_input_file = '/mnt/c/Users/sgoodall/Desktop/archive/NLPProjekt/phptesting/tex2bib-master/ss_det.bbl'  # '/mnt/c/Users/sgoodall/Desktop/archive/NLPProjekt/phptesting/tex2bib-master/example-cites.tex'
    php_convertion_script_file = '/mnt/c/Users/sgoodall/Desktop/archive/NLPProjekt/phptesting/tex2bib-master/index.php'

    bibitemparser = BibitemParser(php_convertion_script_file)

    author_title_tuples = bibitemparser.convert_texfile_2_author_title_tuples(tex_input_file=tex_input_file)
    for at in author_title_tuples:
        print("Author:", at[0])
        print("Title:", at[1])
        print("\n")
    print(bibitemparser.check_how_many_titles_are_usable(author_title_tuples))
